#!/bin/bash
# plot multiple files on single plot with gnuplot
# =================================================
# Author: Michael B Hynes, mbhynes@uwaterloo.ca
# License: GPL 3
# Creation Date: Mon Jan 26 13:33:27 2015
# Last Modified: Mon Jan 26 21:09:49 2015
#=================================================

# add character escapes to certain strings
escape_tex_chars() {
	echo "$@"
	# echo "$@" | sed -r -e 's/\\/\\\\/g; s/\$/\\$/g;'
	# echo "$@" | sed -r -e 's/\\/\\\\/g; s/\$/\\$/g;'
}

# default plot header
generate_header() {
	cat <<EOF 
#
# $(date)
#

set terminal $terminal size $terminal_size color colortext font '$font' linewidth $linewidth
set samples 500, 500
set border linewidth $linewidth
set style fill solid 2.70 noborder
set style data lines

set $xrange
set $yrange

# Line styles 
set style line 1 lc rgb "#A00000" lt 1 lw $linewidth pt 13 ps 1.5
set style line 2 lc rgb "#00A000" lt 1 lw $linewidth pt 3 ps 1.2
set style line 3 lc rgb '#0060ad' lt 1 lw $linewidth pt 9 ps 1.5 
set style line 4 lc rgb "#ad0060" lt 1 lw $linewidth pt 5 ps 1.2
set style line 5 lc rgb "#F25900" lt 1 lw $linewidth pt 7 ps 1.5
set style line 6 lc rgb '#aa0b1d' lt 1 lw $linewidth pt 14 ps 1.5 
set style line 7 lc rgb '#60ad00' lt 1 lw $linewidth pt 1 ps 1.5 

# Fill styles 
set style fill border
# set style fill solid 0.6 border

# Line style for axes
set style line 80 lt 1 lc rgb "#000000" lw $((linewidth-1))

# Line style for grid
set style line 81 lt 1 lc rgb "#808080" lw 1
set grid back linestyle 81

# Remove border on top and right.  
set border 3 back linestyle 80 
    
set xtics nomirror
set ytics nomirror
set xtics norangelimit
set format '%g'

# logscale options
#set log x
#set mxtics 10    

set datafile missing "NaN"

EOF
}

DEFAULT_TERM="postscript eps enhanced"

OPTSTRING=t:ex:y:L:h:o:P:T:f:s:w:FX:Y:
while getopts $OPTSTRING opt; do
	case $opt in
		t)
			timeformat="$OPTARG"
			;;
		X)
			xrange="$OPTARG"
			;;
		Y)
			yrange="$OPTARG"
			;;
		F)
			filled="true"
			;;
		s)
			terminal_size="$OPTARG"
			;;
		T)
			terminal="$OPTARG"
			;;
		w) 
			linewidth="$OPTARG"
			;;
		f)
			font="$OPTARG"
			;;
		o)
			fout="$OPTARG"
			;;
		e)
			errorbars="true"
			;;
		x)
			xtit="$OPTARG"
			;;
		y)
			ytit="$OPTARG"
			;;
		L) # read legend strings into array
			read -a legend <<< "$OPTARG"
			;;
		P)
			leg_pos="$OPTARG"
			;;
		h)
			header="$OPTARG"
			;;
		:)
			echo "-$opt requires argument"
			exit 1
			;;
		\?) 
			echo "invalid option -$opt"
			;;
	esac
done

shift $((OPTIND - 1))

nfiles=$#
if ((nfiles == 0)); then
	echo usage: $0 -o fout "[opts]" fin1 fin2 ...
	disp_opts -h -n 10 $0 2>/dev/null
	exit 1
fi

if [ -z "$fout" ]; then
	disp_opts -h -n 10 $0 2>/dev/null
	exit 1
fi

# check if variables are set; else set defaults
if [ -z "$linewidth" ]; then
	linewidth=2
fi

if [ -z "$terminal_size" ]; then
	terminal_size="6,3"
fi

if [ -z "$terminal" ] && [ -z "$header"]; then
	terminal=$DEFAULT_TERM
fi

if [ -z "$font" ]; then
	font="Courier,20,Bold" 
fi

if [ -z "$xrange" ]; then
	xrange="autoscale x"
else
	if [[ "${xrange:0:1}" != '[' ]]; then
		xrange="xrange [$xrange]"
	else
		xrange="xrange $xrange"
	fi
fi

if [ -z "$yrange" ]; then
	yrange="autoscale y"
else
	if [[ "${yrange:0:1}" != '[' ]]; then
		yrange="yrange [$yrange]"
	else
		yrange="yrange $yrange"
	fi
fi

# generate script to pass to gnuplot
plot_script=$(mktemp)

# write header to script
if [ -r "$header" ]; then
	cat $header > $plot_script
else

	# change output filetype to default .tex
	# if [[ "$terminal" == "$DEFAULT_TERM" ]]
	# then
	# 	fout_ext=$(ext $fout)
	# 	fout_prefix=$(basename $fout $fout_ext)
	# 	fout=$fout_prefix.tex
	# fi

	generate_header > $plot_script
	if [ -n "$timeformat" ]; then
		cat >> $plot_script <<EOF
set xdata time
set timefmt "$timeformat"
EOF
	fi
fi

# set the x,y labels, if they exist
if [ "$xtit" ]; then
	echo "set xlabel '$(escape_tex_chars $xtit)'" >> $plot_script
fi
if [ "$ytit" ]; then
	echo "set ylabel '$(escape_tex_chars $ytit)'" >> $plot_script
fi

# set the legend, if it exists
# leg_pos allows position info to be entered; it may be empty
if [ "$legend" ]; then
	echo "set key $leg_pos reverse enhanced autotitle nobox" >> $plot_script
else
	echo "set key off" >> $plot_script
fi

# set output file
echo "set output '$fout'" >> $plot_script

# =============================================
# plot files
# =============================================
k=0
for file in "$@"; do
	ncols=$(head -n 1 $file | wc -w)

	if ((ncols == 1)); then
		echo "WARNING: $file contains only $ncols columns---skipping" 1>&2
		continue
	fi

	if [ -z "${legend[k]}" ]; then
		leg_entry=""
	else
		leg_entry="$( escape_tex_chars ${legend[k]} )"
	fi
	echo Adding "$leg_entry" to plot

# =============================================
# plotting is divided into sections: 
# 	multiple plots require linebreaks + commas

	num=$((k+1))
	line="ls $num"

# =============================================
# check if only 1 file is given:
	if (($# == 1)) ; then
		if [ "$errorbars" ] && ((ncols > 2));	then
			if [ "$filled" ];	then
				echo "plot '$file' using 1:(\$2-\$3):(\$2+\$3) title '$leg_entry' with filledcurves \\" >> $plot_script
			else
				echo "plot '$file' title '$leg_entry' with errorbars $line, \\" >> $plot_script
				echo "	'' using 1:2 notitle with lines ls $num \\" >> $plot_script
			fi
		else
			echo "plot '$file' using 1:2 title '$leg_entry' $line \\" >> $plot_script
		fi
		continue
	fi

# =============================================
# first plot command; use filename, follow with comma and linebreak
	if ((k == 0)) ;	then
		if [ "$errorbars" ] && ((ncols > 2));	then
			if [ "$filled" ];	then
				echo "plot '$file' using 1:(\$2-\$3):(\$2+\$3) title '$leg_entry' with filledcurves, \\" >> $plot_script
			else
				echo "plot '$file' title '$leg_entry' with errorbars $line, \\" >> $plot_script
				echo "	'' using 1:2 notitle with lines ls $num, \\" >> $plot_script
			fi
		else
			echo "plot '$file' using 1:2 title '$leg_entry' $line, \\" >> $plot_script
		fi

# =============================================
# last plot command:
# 	no filename, no linebreak
	elif ((k+1 == nfiles)) ;	then
		if [ "$errorbars" ] && ((ncols > 2));	then
			if [ "$filled" ];	then
				echo "	'$file' using 1:(\$2-\$3):(\$2+\$3) title '$leg_entry' with filledcurves" >> $plot_script
			else
				echo "	'$file' title '$leg_entry' with errorbars $line, \\" >> $plot_script
				echo "	'' using 1:2 notitle with lines ls $num" >> $plot_script
			fi
		else
			echo "	'$file' using 1:2 title '$leg_entry' $line" >> $plot_script
		fi

# =============================================
# middle plot commands
# 	no filename, comma + linebreak
	else
		if [ "$errorbars" ] && ((ncols > 2));	then
			if [ "$filled" ];	then
				echo "	'$file' using 1:(\$2-\$3):(\$2+\$3) title '$leg_entry' with filledcurves, \\" >> $plot_script
			else
				echo "	'$file' title '$leg_entry' with errorbars $line, \\" >> $plot_script
				echo "	'' using 1:2 notitle with lines ls $num, \\" >> $plot_script
			fi
		else
			echo "	'$file' using 1:2 title '$leg_entry' $line, \\" >> $plot_script
		fi
	fi

	((k++))
done

# echo "replot" >> $plot_script
cat $plot_script
gnuplot $plot_script
rm $plot_script

# convert default output to eps 
# if [[ "$terminal" == "$DEFAULT_TERM" ]]
# then
# 	latex $fout 1>&2 2>/dev/null
# 	dvips -o $fout_prefix.eps $fout_prefix.dvi 1>&2 2>/dev/null
# 	rm $fout_prefix.dvi
# fi

exit
